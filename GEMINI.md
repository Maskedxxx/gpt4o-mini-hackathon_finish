# GEMINI.md (RU)

Этот файл — мое руководство для эффективной работы с репозиторием "AI Resume Assistant".

## 1. Цель проекта

Проект является комплексным ассистентом для соискателей. Ключевые функции:
*   **GAP-анализ:** Сравнение резюме с требованиями вакансии.
*   **Сопроводительные письма:** Генерация персонализированных писем.
*   **Чек-листы для интервью:** Создание планов подготовки к собеседованию.
*   **Симуляция интервью:** Проведение тестовых интервью с AI-агентами.

## 2. Архитектура системы

Система состоит из набора взаимосвязанных сервисов, написанных на Python с использованием FastAPI и Aiogram.

*   **Интерфейсы (фронтенды):**
    *   **Telegram Бот:** (`src/tg_bot/`) — основной интерфейс на базе `aiogram` с использованием FSM для управления диалогами.
    *   **Единое веб-приложение:** (`src/web_app/unified_app/`, порт `3000`) — объединяет все веб-функции в одном месте.
    *   **Отдельные веб-приложения:** (`src/web_app/*`, порты `8000`-`8003`) — четыре независимых FastAPI-приложения для каждой функции.

*   **Бэкенд и основная логика:**
    *   **Интеграция с HH.ru:** (`src/hh/`) — отвечает за OAuth2 авторизацию и взаимодействие с API HeadHunter.
    *   **LLM-сервисы:** (`src/llm_*`) — модули, использующие большие языковые модели для выполнения ключевых AI-задач.
    *   **Парсеры:** (`src/parsers/`) — извлекают структурированные данные из PDF-резюме и ответов HH.ru API.
    *   **Модели данных:** (`src/models/`) — Pydantic-модели, определяющие и валидирующие все основные сущности (резюме, вакансии и т.д.).
    *   **Сервер OAuth:** (`src/callback_local_server/`, порт `8080`) — локальный сервер для обработки редиректа от HH.ru.

## 3. Ключевые файлы для работы

При выполнении задач я буду обращаться к следующим файлам:

*   **Менеджер задач:** `TASKS.md` — **Всегда проверять в первую очередь!** Содержит актуальные и приоритетные задачи.
*   **Запуск веб-приложения:** `run_unified_app.py` — точка входа для единого веб-интерфейса.
*   **Запуск Telegram-бота:** `src/tg_bot/main.py`.
*   **Модели данных:** `src/models/resume_models.py` и `src/models/vacancy_models.py`.
*   **Парсер PDF:** `src/parsers/pdf_resume_parser.py`.
*   **Логика LLM-сервисов:** Файлы `*_analyzer.py` или `*_generator.py` внутри директорий `src/llm_*`.

## 4. Критически важные особенности моделей данных

Несогласованность типов данных — главный источник потенциальных ошибок. Я должен обрабатывать их предельно аккуратно.

*   **Модель резюме (`ResumeInfo`):**
    *   `total_experience`: Может быть `int` (опыт в месяцах) или объектом `TotalExperience` (`{"months": 27}`). **Это подтвержденный источник багов (см. `TASKS.md`).**
    *   `skills`: Может быть списком `List[str]` или единой строкой `str`.

*   **Модель вакансии (`VacancyInfo`):**
    *   `experience`: Может быть словарем `dict` (например, `{'id': 'between1And3'}`) или числом `int`.
    *   `key_skills`: Всегда является списком словарей `List[Dict]` (например, `[{'name': 'Python'}]`).

**Обязательный паттерн для безопасной работы с данными:**
```python
# Пример безопасной обработки поля total_experience
total_exp_data = resume_info.get('total_experience')
months = 0
if isinstance(total_exp_data, dict):
    months = total_exp_data.get('months', 0)
elif isinstance(total_exp_data, int):
    months = total_exp_data
```

## 5. Порядок запуска системы (для тестирования)

**1. Настройка окружения:** Убедиться, что файл `.env` создан из `env_example.sh` и содержит все необходимые ключи (`OPENAI_API_KEY`, `HH_*`).

**2. Порядок запуска критически важен:**

   a. **Сервер OAuth (запускать первым):**
      ```bash
      python -m src.callback_local_server.main
      ```
   b. **Основное приложение (рекомендуется единое веб-приложение):**
      ```bash
      python run_unified_app.py
      ```

## 6. Моя стратегия работы

1.  **Анализ задачи:** Начинаю каждую задачу с изучения `TASKS.md` и запроса пользователя.
2.  **Исследование кода:** Использую `read_file` и `glob` для анализа релевантных файлов, уделяя особое внимание моделям в `src/models/` и сервисам, которые их используют.
3.  **Планирование:** Формулирую четкий план изменений.
4.  **Реализация:** Вношу изменения, используя `replace` или `write_file`. **Всегда** пишу код с учетом проверок типов данных, как указано в разделе 4.
5.  **Проверка:** После внесения изменений проверяю работоспособность. По возможности использую отладочные скрипты из `tests/debug_*`. Если автоматическая проверка невозможна, я попрошу пользователя помочь с верификацией.
